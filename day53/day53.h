#ifndef _DAY53_
#define _DAY53_
#include <iostream>
//#define T1 //折半查找算法
//#define T2 //二叉树的创建与遍历
#define T3 //二叉排序树的创建
/*
    查找算法
    静态查找和动态查找
    静态查找：数据集合稳定，不需要添加，删除元素的查找
    操作。
    动态查找：数据集合在查找的过程中需要同时添加或删除
    元素的查找操作。
    1.顺序查找-->逐个进行比较
    2.插值查找-->在折半插值的基础上(按比例查找)
    它的前提是线性表中的记录必须是有序的，新型表必须采用
    顺序存储。基于二分查找，将查找点的选择改进为自适应
    选择，可以提高查找效率
    即mid = low + (key-a[low])*(high-low)/(a[high]-a[low])
    适用情况：数据量大，分布均匀
    3.斐波那契查找
    斐波那契数列：1 1 2 3 5 8 13 21 34 55 89...
    F(k) = F(k-1) + F(k-2);k >= 3
    对于斐波那契数列：1、1、2、3、5、8、13、21、34、55、89……（也可以从0开始），
    前后两个数字的比值随着数列的增加，越来越接近黄金比值0.618。
    比如这里的89，把它想象成整个有序表的元素个数，而89是由前面
    的两个斐波那契数34和55相加之后的和，也就是说把元素个数为89的
    有序表分成由前55个数据元素组成的前半段和由后34个数据元素组成的
    后半段，那么前半段元素个数和整个有序表长度的比值就接近黄金比值0.618，
    假如要查找的元素在前半段，那么继续按照斐波那契数列来看，55 = 34 + 21，
    所以继续把前半段分成前34个数据元素的前半段和后21个元素的后半段，继续查找，
    如此反复，直到查找成功或失败，这样就把斐波那契数列应用到查找算法中了。
    
    注：当有序表的元素个数不是斐波那契数列中的某个数字时，需要把有序表的
    元素个数长度补齐，让它成为斐波那契数列中的一个数值

    优点：斐波那契查找的时间复杂度还是O(log2n)，但是与折半
    查找相比，斐波那契查找的优点是它只涉及加法和减法运算，而不用
    除法，而除法比加减法要占用更多的时间，因此，斐波那契查找
    的运行时间理论上比折半查找小。

    4.线性索引查找
    数据结构的最终目的就是提高数据的处理速度，索引是为了
    加快查找速度而设计的一种数据结构。索引就是把一个关键字
    与它对应的记录相关联的过程。
    稠密索引(数据量不是很大的情况)：
    稠密索引是指在线性索引中，将数据集中的每个记录对应一个
    索引项。
    分块索引:
    三个步骤：
    a:最大关键码--存储每一块中的最大关键字；
    b:存储每一块中国记录的个数以便于循环时使用；
    c:用于指向块首数据元素的指针，便于开始对这一块中记录进行
    遍历
    查找步骤：
    a:在分块索引表中查找要查找的关键字所在块；
    由于分块索引表是块间有序的，因此很容易利用折半插值
    等算法得到结果。
    b:根据块首指针找到相应的块，并在块中顺序查找关键码。
    因为块中是无序的，因此只能顺序查找。

    5.二叉树排序树
    特点：其左子树结点的值都是小于根结点的值，右子树的值
    都是大于根结点的值；
    性质：对二叉排序树进行中序遍历可以得到从小到大的排列。
    二叉排序树删除操作：
    a.删除结点的右子树为空的情况下
    把p结点的地址传给q指针，再把p的左子树的值传递给p，最后
    释放q;
    b.删除结点的左子树为空的情况下
    把p结点的地址传给q指针，再把p的右子树的值传递给p，最后
    释放q。
    c.删除结点的左右子树都不为空时
    置换前驱或后继的值，然后删掉前驱或后继。

    6.平衡二叉树(AVL)
    改进二叉排序数深度的问题，提高查找效率
    特点：左子树和右子树的高度最多只相差1
*/
using namespace std;
namespace DAY53
{
    int HalfFind(int a[],int low,int high,int key);
    struct BiTree
    {
        char data;
        BiTree *lchild,*rchild;
    };
    void CreateBiTree(BiTree* &T);
    void TranverseBiTree(BiTree* T);
}
namespace DAY53A
{
    struct BiTree
    {
        int data;
        BiTree *lchild,*rchild;
    };
    void CreateBiTree(BiTree* T,int data);
    void CreateSortBiTree(BiTree* &T);
    void MidTraverse(BiTree* head);

}


#endif
