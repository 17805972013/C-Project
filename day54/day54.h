#ifndef _DAY54_
#define _DAY54_
#include <iostream>
using namespace std;
//#define T1 //排序算法
#define T2 //插入排序
/*
    哈希表查找算法---实际就是一种映射，尽量一对一的映射关系
    记录的存储位置 = f(关键字)
    散列技术是在记录的存储位置和它的关键字之间确立一个确定
    的对应关系f，使得每个关键字key对应一个存储的位置f(key).

    定义：哈希表查找也叫散列查找，整个散列查找过程大概分为两步
    1.在存储时通过散列函数计算记录的散列地址，并按此散列
    地址存储该记录；
    2.当查找时，一样通过散列函数计算记录的散列地址，然后
    访问散列地址的记录
    散列函数的构造方法
    前提：计算简单+分布均匀=好的散列函数
    1.直接地址法---取某个关键字的某个线性函数值为散列地址
        f(key) = a*key+b
    需要事先知道关键字的分布情况，适合查找表较小且连续的情况。
    2.数字分析法
        使用关键字的一部分来计算散列存储的位置，适合处理关键
        字位数较大的情况。
    3.平方取中法
    假设关键字是1234，那它的平方即使1522756，再取中间
    的3位就是277适合不知道关键字的分布，而位数又不是很大
    的情况。
    4.折叠法
    将关键字从左到右分割成位数相等的几个部分，然后将这几部分
    叠加求和，并按散列表表长，取后几位作为散列地址。比如关键字
    9876543210，散列表表长为三位，我们将它分为四组，
    987|654|321|0，然后将他们叠加求和等于1962，再求后三位
    得到散列地址962.
    适合事先不知道关键字的分布，关键字位数较多的情况
    5.除留余数法
    散列表查找算法实现
    1.首先定义一个散列表结构；
    2.对散列表进行初始化；
    3.对散列表进行插入操作；
    4.根据不同的情况选择散列函数和处理冲突的方法
    重点介绍散列冲突的解决方法
    开放地址法
    线性探索法
    f[i](key) = (f(key)+d[i]) MOD m (d[i] = 1^2,-1^2,2^2,-2^2,-q^2,q<=m/2)
    再散列函数法
    f[i](key) = RH[i](key)
    链地址法
    重复的部分用一个单链表链接过去
    公共溢出表
    重复部分再增加一个溢出表格进行存储

    排序算法
    影响排序算法性能的几个要素：
    1.时间性能；
    2.辅助空间；
    3.算法的复杂性。
    冒泡排序的要点：
    -->最大 -->次大 -->.. -->最小
    1.比较相邻的元素。如果第一个比第二个大，就交换他们两个；
    2.对每一队相邻元素做同样的工作，从开始第一对到结尾最后
    一对。
    3.针对所有的元素重复以上的步骤，除了最后一个；
    4.持续每次对越来越少的元素重复上面的步骤，直到没有任何
    一对数字需要比较。
    选择排序的要点：
    最小<-- 次小<-- ..<-- 最大<--
   从头至尾扫描序列，找出最小的一个元素和第一个元素交换
   接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序
   序列。
   直接插入排序要点
   插入排序的基本方法是，每一步将一个待排序的元素，按其
   排序码的大小，插入到全面已经排好的一组元素的适当位置上去，直到
   元素全部插入为止。
   
   希尔排序要点
   插入排序的跨度为1.
   插入排序的基础上，对跨度比较上进行的改善(5,3,2,1);
   
   堆排序要点
   根结点一定是堆中所有结点最大或者最小者，即满足
   k[i] >= K[2*i],k[i]>=k[2*i+1] 或者
   ...   <=
   1.将待排序的序列构造成一个大顶堆(或小顶堆)。
   2.此时，整个序列的最大值就是堆顶的根结点。将它移走(就是
   将其与堆数组的末尾元素交换，此时末尾元素就是最大值。)
   3.然后将剩余的n-1个序列重新构造成一个堆，这样就会得到
   n个元素中的此大值；
   4.如此反复执行，便得到一个有序序列了。

   归并排序
   归并排序的核心思想就是将两个有序的数列合并成一个大的有序
   的序列。通过递归，层层合并，即为归并。
   
   快速排序
    增加前后两个哨兵
    1.i = L;j = R；将基准数挖出形成第一个坑a[i]。
    2.j--由后向前找比它小的数，找到后挖出此数填前
    一个坑a[i]中。
    3.i++由前向后找比它大的数，找到后也挖出此数填到前
    一个坑a[j]中。
    4.再重复执行2,3两步直到i==j,将基准数填入a[i]中。
*/
namespace DAY54
{
    int m = 0;
    enum{HASHSIZE=10,NULLKEY=-32768};
    typedef struct
    {
        int *elem;//数据元素基地址，动态分配数组
        int count;

    }HashTable;
    int Init(HashTable *H);
    int Hash(int k)
    {
        return k%m;
    }
    void Insert(HashTable *H,int k);
    int Search(HashTable *H,int k);
    void Result(HashTable *H);

}
namespace DAY54A
{
    struct Node
    {
        int data;
        Node* next;
    };
    void InsertSort(Node* &head,int data);
    void InsertSort_1(int a[]);
}
#endif